import { NextRequest, NextResponse } from 'next/server';
import { requireAuth } from '@/lib/auth';
import { db } from '@/db';
import { playlists, playlistMembers, playlistTracks, circleMembers } from '@/db/schema';
import { eq, and, isNull, isNotNull } from 'drizzle-orm';
import {
  followPlaylist,
  updatePlaylistDetails,
  TokenInvalidError,
  SpotifyRateLimitError,
} from '@/lib/spotify';
import { generateId, formatPlaylistName, getFirstName } from '@/lib/utils';

// POST /api/playlists/[playlistId]/join — join via invite code or circle membership
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ playlistId: string }> }
) {
  const user = await requireAuth();
  const { playlistId } = await params;
  const body = await request.json();
  const { inviteCode, circleJoin } = body;

  const playlist = await db.query.playlists.findFirst({
    where: eq(playlists.id, playlistId),
    with: { members: { with: { user: true } } },
  });

  if (!playlist) {
    return NextResponse.json({ error: 'Playlist not found' }, { status: 404 });
  }

  // Authorization: invite code OR circle membership
  if (circleJoin) {
    const membership = await db.query.circleMembers.findFirst({
      where: and(eq(circleMembers.circleId, playlist.circleId), eq(circleMembers.userId, user.id)),
    });
    if (!membership) {
      return NextResponse.json({ error: 'Not a member of this circle' }, { status: 403 });
    }
  } else if (playlist.inviteCode !== inviteCode) {
    return NextResponse.json({ error: 'Invalid invite code' }, { status: 403 });
  }

  // Check if already a member
  const existing = playlist.members.find((m) => m.user.id === user.id);
  if (existing) {
    return NextResponse.json({ error: 'Already a member' }, { status: 400 });
  }

  // Add to members
  await db.insert(playlistMembers).values({
    id: generateId(),
    playlistId: playlistId,
    userId: user.id,
  });

  // Follow the Spotify playlist
  try {
    await followPlaylist(user.id, playlist.circleId, playlist.spotifyPlaylistId);
  } catch (err) {
    if (err instanceof SpotifyRateLimitError) {
      return NextResponse.json(
        {
          error: 'Spotify is a bit busy right now. Please try again in a minute.',
          rateLimited: true,
        },
        { status: 429 }
      );
    }
    if (err instanceof TokenInvalidError) {
      return NextResponse.json(
        { error: 'Your Spotify session has expired. Please reconnect.', needsReauth: true },
        { status: 401 }
      );
    }
    throw err;
  }

  // Reset completedAt on pending tracks — new member hasn't listened yet
  await db
    .update(playlistTracks)
    .set({ completedAt: null })
    .where(
      and(
        eq(playlistTracks.playlistId, playlistId),
        isNull(playlistTracks.removedAt),
        isNotNull(playlistTracks.completedAt)
      )
    );

  // Update playlist name if it was auto-generated
  const allMembers = [...playlist.members.map((m) => m.user), user];
  const memberFirstNames = allMembers.map((m) => getFirstName(m.displayName));
  const newName = formatPlaylistName(memberFirstNames);

  // Only update name if user hasn't customized it
  const currentNameIsAutoGenerated = playlist.name.endsWith('Swapify');
  if (currentNameIsAutoGenerated) {
    try {
      await updatePlaylistDetails(playlist.ownerId, playlist.circleId, playlist.spotifyPlaylistId, {
        name: newName,
      });
    } catch (err) {
      if (err instanceof SpotifyRateLimitError) {
        return NextResponse.json(
          {
            error: 'Spotify is a bit busy right now. Please try again in a minute.',
            rateLimited: true,
          },
          { status: 429 }
        );
      }
      if (err instanceof TokenInvalidError) {
        return NextResponse.json(
          { error: 'Your Spotify session has expired. Please reconnect.', needsReauth: true },
          { status: 401 }
        );
      }
      throw err;
    }
    await db.update(playlists).set({ name: newName }).where(eq(playlists.id, playlistId));
  }

  // Notify existing members that someone joined
  import('@/lib/notifications').then(({ notifyPlaylistMembers }) => {
    notifyPlaylistMembers(
      playlistId,
      user.id,
      {
        title: 'New member joined',
        body: `${user.displayName} joined "${playlist.name}"`,
        url: `${process.env.NEXT_PUBLIC_APP_URL}/playlist/${playlistId}`,
      },
      'memberJoined'
    );
  });

  return NextResponse.json({ success: true, playlistId });
}
